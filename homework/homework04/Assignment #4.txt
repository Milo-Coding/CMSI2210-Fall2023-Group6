Answers to homework #4

1. X := A or (B and C)
   Y := Not-A or C

2. Drawing in pdf

3. Assume the intital value is stored in accumulator A0 for all problems and setting it equal to the answer is sufficient to solve the problem
   a. AND A0,   A0,     #0xAAAAAAAA     ; Clear even bits by ANDing with the all even bits as 0s and all odd bits as 1s
                                        ; (I assumed #0xAAAAAAAA but if the rightmost bit is bit 0 instead of bit 1 then use #0x55555555)
   
   b. OR A0,    A0,     #0x00000007     ; Set the last three bits by ORing with just the last 3 bits active (#0x00000007)
   
   c. MOD A0,   A0,     #0x00000008     ; Use Modulo to get remainter
      
   cool bonus way I found:
      AND A0,   A0,     #0x00000007     ; Use bitwise AND with 0x00000007 to keep only the remainder (value < 8)
   
   d. OR A0,    A0,     #FFFFFFFF       ; Set all bits to 1 (this is -1 in a signed interpretation) by ORing
   
   e. XOR A0,   A0,     #0xC0000000     ; Complement the two highest order bits by XORing with the hightest order bits set to 1s
   
   f. temp,     #0x00000000             ; Create a new accumulator to store a value
      MOD temp, A0,     #0x00000008     ; Store the remainder of value/8 in temp
      SUB A0,   A0,     temp            ; Subtract the remainder to set our initial value equal to the largest multiple of 8 less than or equal to itself

4.      JMP     start   ; begin by jumping over the data area
 count: 0               ; store the current counter value here
   inc: 1               ; store the value 1 to add each step
 limit: 255             ; we'll be counting up to this amount
 start: LOAD count      ; bring the value into accumulator to use
        WRITE   #0x8    ; output the current count to port 8
        ADD     inc     ; adding 1 to itself makes the next number!
        STORE   count   ; store it (for next loop)
        SUB     limit   ; we need to compare with limit, subtracting helps
        JLZ     start   ; if not yet at 255, keep going
   end: JUMP    end     ; this "stops" the program!

5. C0000004
   00000001
   00000001
   000000FF
   00000001
   30000008
   40000002
   10000001
   50000003 
   E0000004
   C000000A

6.      JMP     start   ; begin by jumping over the data area
  num1: 0               ; create some nums to store our values
  num2: 0               ;
   gcd: 0               ; default greatest common divisor is 1
   one: 1               ; number 1 for loop
 start: READ    0x100   ; get the first value from port 0x100
        STORE   num1    ; store it in num1
        READ    0x100   ; get the second value from port 0x100
        STORE   num2    ; store it in num2
        ADD     one     ; increase the value by one for looping (we'll subtract it again before the first check)
        STORE   gcd     ; put the value of num2 in gcd too as the greatest potential gcd
  loop: LOAD    gcd     ; get the current gcd
        SUB     one     ; subtract one from it to move to the next lowest potential gcd
        STORE   gcd     ; store that value to check later
        LOAD    num1    ; put num1 in the accumulator
        MOD     gcd     ; get the remainder of the current guess of the gcd
        JLZ     loop    ; if not zero, then not a divisor so try next number (checks lower)
        JGZ     loop    ; if not zero, then not a divisor so try next number (checks upper)
        LOAD    num2    ; put num2 in the accumulator and compleat the same process
        MOD     gcd     ; 
        JLZ     loop    ; 
        JGZ     loop    ; if you get past this line without jumping you found the gcf
        LOAD    gcf     ; put the gcd in the accumulator 
        WRITE   0x200   ; write the gcd to port 0x200
   end: JUMP    end     ; this "stops" the program!


7. 
For the sample single-accumulator computer discussed in class, give a code fragment, in assembly language of the stanley/penguin language, that swaps the accumulator and memory address 0x30AA. You do not need to write machine code for this problem.

8. 
For the sample single-accumulator computer discussed in class, give a code fragment, in assembly language of the stanley/penguin language that has the effect of jumping to the code at address 0x837BBE1 if the value in the accumulator is greater than or equal to 0. You do not need to write machine code for this problem.

9. Part 1:
Explain, at a high-level, what the following sequence of instructions does. In other words, suppose a programmer has stored data in r8 and r9. After executing these instructions, what does the programmer notice about the data?
      xor r8, r9
      xor r9, r8
      xor r8, r9
   Part 2:
   Also state as briefly as possible why that effect happens.